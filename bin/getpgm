#!/usr/bin/env python

# stdlib imports
import argparse
from collections import OrderedDict
import datetime
import glob
import importlib
import inspect
import os.path
import pkgutil
import sys
import warnings

# local imports
from amptools.exception import AmptoolsException
from amptools.process import filter_detrend
from amptools.stream import _group_channels
from pgm.exception import PGMException

# third party imports
import pandas as pd


EXCLUDED_MODULES = ['base.py', '__init__.py']
VALID_FORMATS = ['cosmos', 'cwb', 'dmg', 'geonet', 'knet']


def get_timeseries(input_source, input_format):
    """
    Read files from a directory and return stream objects.

    Args:
        input_source (str): Path to input files.
        input_format (str): File format.

    Returns:
        list: List of obspy.core.stream.Stream objects
    """
    # TODO: If input_format == db, get from COMCAT and CWB
    # Check that the file format is valid
    if input_format.lower() not in VALID_FORMATS:
        raise AmptoolsException('%r is not a supported format. Supported '
                'formats are: %r' % (input_format, VALID_FORMATS))
    # Create the module and function name from the request
    reader = 'amptools.io.' + input_format + '.core'
    function_name = 'read_' + input_format
    # Import modeule and function
    reader_module = importlib.import_module(reader)
    read_method =  getattr(reader_module, function_name)
    # Read, group, and return streams
    streams = []
    for file_path in glob.glob(input_source + '/*'):
        streams += [read_method(file_path)]
    streams = _group_channels(streams)
    return streams


def main(args):
    """
    Loop over requested pgm types and call module.getPGM() for each valid
    request.

    Args:
        ArgumentParser: argparse argument object.

    Notes:
        Results in a dictionary of PGM values in the following format:
        {
            <station code>: {
                <channel code>: {
                    metadata: {
                        * key/value dictionary from trace.stats
                    },
                    PGM: {
                        <requested IMT>: file_format,
                        ...
                    }
                },
                components: {
                    <requested IMC>: {
                        timeseries: obspy.core.trace.Trace,
                        <requested IMT>: float,
                        ...
                    },
                    ...
                }
            },
            ...
        }
    """
    # Check import arguments
    if args.input_source is not None:
        input_source = args.input_source
    else:
        raise AmptoolsException('No input source specified.')
    if args.output_directory is not None:
        output_directory = args.output_directory
        # Create directory if it doesn't exist
        if not os.path.exists(output_directory):
                os.makedirs(output_directory)
    else:
        raise AmptoolsException('No output directory specified.')
    if args.format is not None:
        input_format = args.format
    else:
        raise AmptoolsException('No input format specified.')
    # Get streams
    streams = get_timeseries(input_source, input_format)
    # Process the data
    with warnings.catch_warnings():
        warnings.simplefilter("ignore")
        streams = process_streams(streams)
    # Get IMT and IMC import dictionaries
    _imt_classes_ = _get_pgm_classes('imt')
    _imc_classes_ = _get_pgm_classes('imc')
    # Create a dictionary of PGM values
    if args.intensity_measurements is not None:
        arglist = args.intensity_measurements.copy()
        pgm_list, pgm_dict = _get_requested_imts(args, arglist,
                _imt_classes_, streams)
        pgm_dict = _get_requested_imcs(args, _imc_classes_, pgm_dict, pgm_list, streams)
        # Output flatfile and PGM tables
        output_flatfile(output_directory, pgm_dict)
        output_tables(output_directory, pgm_dict, pgm_list)
    else:
        raise PGMException('At least one IMT must be specified.')


def process_streams(streams):
    """
    Perform basic processing on streams.

    Args:
        streams (list): List of streams (obspy.core.stream.Stream).

    Returns:
        list: List of obspy.core.stream.Stream objects
    """
    # TODO: Possibly let the user pick the filter settings
    for stream in streams:
        for idx, trace in enumerate(stream):
            stream[idx] = filter_detrend(trace, taper_type='cosine',
                    taper_percentage=0.05, filter_type='highpass',
                    filter_frequency=0.02, filter_zerophase=True,
                    filter_corners=4)
    return streams


def output_flatfile(output_directory, pgm_dictionary):
    """
    Outputs a simplified flatfile.

    Args:
        output_directory (str): Path to output directory.
        pgm_dictionary (dictionary): Dictionary of pgm values.

    Notes:
        Headers:
            - Record Sequence Number
            - YEAR
            - MODY
            - HRMN
            - Station Name
            - Station ID  No.
            - Station Latitude
            - Station Longitude
            - Channel
            - All requested PGM values (one type per column)
            ...
            - Processing Comments
        The flatfile is exported as a csv with the following filename convention:
            <YEAR>_<MONTH>_<DAY>_flatfile.csv
    """
    # Set metadata column headers
    columns = ['Record Sequence Number', 'YEAR', 'MODY', 'HRMN',
            'Station Name', 'Station ID  No.', 'Station Latitude',
            'Station Longitude', 'Channel']
    # Initialize dictionary
    dataframe_dict = OrderedDict()
    for col in columns:
        dataframe_dict[col] = []
    counter = 0
    for station_key in pgm_dictionary:
        station = pgm_dictionary[station_key]['channels']
        for channel_key in station:
            counter += 1
            channel = station[channel_key]
            # Set metadata
            dataframe_dict['Record Sequence Number'] += [counter]
            metadata = channel['metadata']
            dataframe_dict['YEAR'] += [metadata['starttime'].year]
            # Format the date
            month = '{:02d}'.format(metadata['starttime'].month)
            day = '{:02d}'.format(metadata['starttime'].day)
            dataframe_dict['MODY'] += [month + day]
            hour = '{:02d}'.format(metadata['starttime'].hour)
            minute = '{:02d}'.format(metadata['starttime'].minute)
            dataframe_dict['HRMN'] += [hour + minute]
            dataframe_dict['Station Name'] += [metadata['name']]
            dataframe_dict['Station ID  No.'] += [metadata['station']]
            dataframe_dict['Station Latitude'] += [metadata['lat']]
            dataframe_dict['Station Longitude'] += [metadata['lon']]
            dataframe_dict['Channel'] += [metadata['channel']]
            # Set PGM values
            for pgm in channel['PGM']:
                if counter == 1:
                    dataframe_dict[pgm] = []
                    dataframe_dict['Processing Comments'] = []
                dataframe_dict[pgm] += [channel['PGM'][pgm]['value']]
            # Set processing comments
            dataframe_dict['Processing Comments'] += [metadata['processing']]
    # Create pandas dataframe
    dataframe = pd.DataFrame(data=dataframe_dict)
    # Create file path
    today = datetime.datetime.now().strftime("%Y_%m_%d")
    filename = today + '_flatfile.csv'
    path = os.path.join(output_directory, filename)
    # Export csv
    writer = dataframe.to_csv(path, mode = 'w', index=False)


def output_tables(output_directory, pgm_dictionary, pgm_list):
    """
    Outputs a table of IMCs vs IMTs.

    Args:
        output_directory (str): Path to output directory.
        pgm_dictionary (dictionary): Dictionary of pgm values.
        pgm_list (dictionary): Record of requested IMTs.

    Notes:
        The table is formated with IMCs as the column labels and IMTs
        as the row labels.

        The table is exported as a csv with the following filename convention:
            <station>.csv
    """
    # Initialize dictionary
    dataframe_dict = OrderedDict()
    dataframe_dict[''] = []
    for imt in set(pgm_list):
        dataframe_dict[''] += [imt]
    # Get channel columns
    for station_key in pgm_dictionary:
        station = pgm_dictionary[station_key]['channels']
        for channel_key in station:
            channel = station[channel_key]
            dataframe_dict[channel_key] = []
            for imt in set(pgm_list):
                dataframe_dict[channel_key] = channel['PGM'][imt]['value']
    # Get calculated IMC columns
    for station_key in pgm_dictionary:
        station = pgm_dictionary[station_key]['components']
        for component_key in station:
            component = station[component_key]
            dataframe_dict[component_key] = []
            for imt in set(pgm_list):
                dataframe_dict[component_key] += [component[imt]]
        # Create pandas dataframe
        dataframe = pd.DataFrame(data=dataframe_dict)
        # Create file path
        filename = station_key + '.csv'
        path = os.path.join(output_directory, filename)
        # Export csv
        writer = dataframe.to_csv(path, mode = 'w', index=False)


def _get_metadata(stream):
    """
    Internal method to get dictionary of metadata for one station.

    Args:
        stream (obspy.core.stream.Stream): Stream of strong ground motion.

    Returns:
        tuple: Tuple of station and metadata (str, dictionary).
    """
    # TODO: Simplify processing metadata
    metadata = OrderedDict()
    for trace in stream:
        station = trace.stats['station']
        channel = trace.stats['channel']
        metadata[channel] = OrderedDict()
        for key in trace.stats:
            if key != 'units':
                metadata[channel][key] = trace.stats[key]
    return station, metadata


def _get_parser():
    """
    Internal method to get argparse parser instance.

    Returns:
        ArgumentParser: argparse argument parser.
    """
    description = '''
    Get requested PGM values.
    '''
    # Get valid classes
    _imt_classes_ = _get_pgm_classes('imt')
    _imc_classes_ = _get_pgm_classes('imc')
    # Create descriptions
    epilog = 'PGM Parameters:\n'
    epilog += '\tAvailable IMTs:\n'
    for key, core_class in _imt_classes_.items():
        epilog += '\t\t- %s\n' % inspect.getdoc(core_class)
    epilog += '\tAvailable IMCs:\n'
    for key, core_class in _imc_classes_.items():
        epilog += '\t\t- %s\n' % inspect.getdoc(core_class)

    epilog += '\nUse "help command" to see the options for a '\
              'specific PGM.\n'
    # Define parser arguments
    parser = argparse.ArgumentParser(
        description=description,
        epilog=epilog,
        formatter_class=argparse.RawDescriptionHelpFormatter)
    parser.add_argument('input_source',
                        help='The directory of all input files.')
    parser.add_argument('output_directory',
                        help='The directory of all output files.')
    parser.add_argument('format',
                        help='Format of the files that are read in.')
    parser.add_argument('-c', '--components', type=str, dest='components',
            default=[], action='append', help='The IMC parameters to get.')
    parser.add_argument('-m', '--intensity-measurements', nargs=argparse.REMAINDER,
                        help='The IMT parameters to get.')
    return parser


def _get_pgm_classes(im_type):
    """
    Create a dictionary of classname:class to be used in main().

    Args:
        im_type (str): Representation of eith intensity measure type
                or component. (imt or imc)

    Returns:
        dictionary: Dictionary of classname:class where each class
            is a subclass of pgm.base.PGM.
    """
    # Get list of available modules (excluding base and __init__)
    modules = _get_pgm_modules(im_type)
    # Put imported modules into a dictionary
    pgm_modules = OrderedDict()
    for modname in modules:
        mod = importlib.import_module(modname)
        cm = {
            mod.__name__: mod
        }
        pgm_modules.update(cm)
    # Put imported classes into a dictionary
    classes = OrderedDict()
    for name, module in pgm_modules.items():
        for m in inspect.getmembers(module, inspect.isclass):
            if m[1].__module__ == name:
                core_class = getattr(module, m[0])
                classes[core_class.__name__] = core_class
    ordered_classes = OrderedDict()
    keys = sorted(classes.keys())
    for k in keys:
        ordered_classes[k] = classes[k]
    return ordered_classes


def _get_pgm_modules(im_type):
    """
    Internal method to get all pgm modules.

    Args:
        im_type (str): Representation of eith intensity measure type
                or component. (imt or imc)

    Returns:
        list: List of pgm modules.
    """
    # Get path
    home = os.path.dirname(os.path.abspath(__file__))
    pgm_directory = os.path.abspath(os.path.join(home, '..', 'pgm', im_type))
    path = 'pgm.' + im_type + '.'
    # Create list
    pgm_modules = []
    for file in os.listdir(pgm_directory):
        if file.endswith(".py") and file not in EXCLUDED_MODULES:
            file = file[0:-3]
            pgm_modules += [path + file]
    return pgm_modules


def _get_requested_imcs(args, _imc_classes_, pgm_dict, pgm_list, streams):
    """
    Internal method for populating the pgm dictionary.

    Args:
        args (argparse.Namespace): Arguments passed.
        _imc_classes_ (dictionary): Dictionary of imported imc classes.
        pgm_dict (dictionary): Dictionary of pgm values. Already populated
            with IMT values.
        pgm_list (dictionary): Record of requested IMTs.
        streams (list): List of obspy.core.stream.Stream objects.

    Returns:
        dictionary: Dictionary of pgm values. Populated
            with IMT and IMC values.
    """
    for imt in set(pgm_list):
        for component in args.components:
            component = component.upper()
            # Check that the class exists and select from import dictionary
            if component not in _imc_classes_:
                raise KeyError('"%s" not a valid imc type.' % component)
            pgm_class = _imc_classes_[component]
            pgm_obj = pgm_class()
            for stream in streams:
                station, metadata = _get_metadata(stream)
                pgm_dict[station]['components'] = {}
                for channel in metadata:
                    units = pgm_dict[station]['channels'][channel]['PGM'][imt]['units']
                pgm_value, imc_timeseries = pgm_obj.getPGM(stream, units=units)
                pgm_dict[station]['components'][component] = {}
                pgm_dict[station]['components'][component]['timeseries'] = imc_timeseries
                pgm_dict[station]['components'][component][imt] = pgm_value
    return pgm_dict


def _get_requested_imts(args, arglist, _imt_classes_, streams):
    """
    Internal method for populating the pgm dictionary.

    Args:
        args (argparse.Namespace): Arguments passed.
        arglist (list): List of all remaining arguments form the parser.
        _imt_classes_ (dictionary): Dictionary of imported imt classes.
        streams (list): List of obspy.core.stream.Stream objects.

    Returns:
        dictionary: Dictionary of pgm values. Populated
            with IMT values.
    """
    oldpgm = ''
    pgm_dict = OrderedDict()
    pgm_list = OrderedDict()
    while(len(arglist) > 0):
        pgm = arglist.pop(0).upper()
        # Check that the class exists and select from import dictionary
        if pgm.startswith('-'):
            raise KeyError('"%s" cannot process option "%s"' %
                           (oldpgm, pgm))
        if pgm not in _imt_classes_:
            raise KeyError('"%s" not a valid imt type.' % pgm)
        pgm_class = _imt_classes_[pgm]
        pgm_obj = pgm_class()
        arglist = pgm_obj.parseArgs(arglist)
        for stream in streams:
            station, metadata = _get_metadata(stream)
            pgm_values = pgm_obj.getPGM(stream)
            pgm_dict[station] = OrderedDict()
            pgm_dict[station]['channels'] = {}
            for channel in metadata:
                channel_dict = {}
                channel_dict['metadata'] = metadata[channel]
                channel_dict['PGM'] = {}
                channel_dict['PGM'][pgm.upper()] = {}
                channel_dict['PGM'][pgm.upper()]['units'] = pgm_obj.getUnits()
                channel_dict['PGM'][pgm.upper()]['value'] = pgm_values[channel]
                pgm_dict[station]['channels'][channel] = channel_dict
        oldpgm = pgm
        pgm_list[pgm] = pgm_obj
        if args.input_source.lower() == 'help':
            arglist = ['-h']
    return pgm_list, pgm_dict


if __name__ == '__main__':
    parser = _get_parser()
    pargs = parser.parse_args()
    if pargs.input_source.lower() == 'help' and len(pargs.intensity_measurements) == 0:
        parser.print_help()
    else:
        main(pargs)
    sys.exit(0)
